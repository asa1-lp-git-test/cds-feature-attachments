package com.sap.cds.feature.attachments.service.malware.client;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Objects;

import org.apache.http.Header;
import org.apache.http.HeaderElement;
import org.apache.http.HttpEntity;
import org.apache.http.StatusLine;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
import org.apache.http.message.BasicHeaderElement;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.ArgumentCaptor;

import com.sap.cds.feature.attachments.service.malware.client.httpclient.HttpClientProviderFactory;
import com.sap.cds.feature.attachments.service.malware.client.model.MalwareScanResultStatus;
import com.sap.cds.integration.cloudsdk.destination.HttpClientProvider;
import com.sap.cds.services.ServiceException;

class DefaultMalwareScanClientTest {

	private DefaultMalwareScanClient cut;
	private HttpClientProviderFactory clientProviderFactory;
	private ArgumentCaptor<HttpEntityEnclosingRequestBase> requestCaptor;

	@BeforeEach
	void setup() {
		clientProviderFactory = mock(HttpClientProviderFactory.class);
		cut = new DefaultMalwareScanClient(clientProviderFactory);

		requestCaptor = ArgumentCaptor.forClass(HttpEntityEnclosingRequestBase.class);
	}

	@Test
	void noServiceBoundReturnsCorrectStatus() {
		when(clientProviderFactory.isServiceBound()).thenReturn(false);

		var result = cut.scanDocument(mock(InputStream.class));

		assertThat(result).isEqualTo(MalwareScanResultStatus.NO_SCANNER);
		verify(clientProviderFactory, never()).getHttpClientProvider();
	}

	@Test
	void contentIsUsedInRequest() throws IOException {
		var document = mock(InputStream.class);
		var httpClient = mockHttpResponse(200, false, false);

		cut.scanDocument(document);

		verify(httpClient).execute(requestCaptor.capture());
		assertThat(requestCaptor.getValue().getEntity().getContent()).isEqualTo(document);
	}

	@Test
	void correctMethodIsUsedInRequest() throws IOException {
		var document = mock(InputStream.class);
		var httpClient = mockHttpResponse(200, false, false);

		cut.scanDocument(document);

		verify(httpClient).execute(requestCaptor.capture());
		var request = requestCaptor.getValue();
		assertThat(request.getMethod()).isEqualTo("POST");
	}

	@Test
	void correctStatusReturnedForSuccessfulScan() throws IOException {
		mockHttpResponse(200, false, false);

		var response = cut.scanDocument(mock(InputStream.class));

		assertThat(response).isEqualTo(MalwareScanResultStatus.CLEAN);
	}

	@ParameterizedTest
	@CsvSource({"true, false", "false, true", "true, true"})
	void correctStatusReturnedForNotCleanResponse(boolean malwareDetected,
			boolean encryptedContentDetected) throws IOException {
		mockHttpResponse(200, malwareDetected, encryptedContentDetected);

		var response = cut.scanDocument(mock(InputStream.class));

		assertThat(response).isEqualTo(MalwareScanResultStatus.INFECTED);
	}

	@Test
	void exceptionIsThrownIfRequestRespondWithException() throws IOException {
		when(clientProviderFactory.isServiceBound()).thenReturn(true);
		var httpClient = mock(HttpClient.class);
		var httpClientProvider = mock(HttpClientProvider.class);
		when(httpClientProvider.get()).thenReturn(httpClient);
		when(clientProviderFactory.getHttpClientProvider()).thenReturn(httpClientProvider);
		when(httpClient.execute(any())).thenThrow(new IOException());

		var inputStream = mock(InputStream.class);
		assertThrows(ServiceException.class, () -> cut.scanDocument(inputStream));
	}

	@ParameterizedTest
	@ValueSource(ints = {100, 199, 208, 300, 400, 500})
	void exceptionIsThrownIfRequestRespondWithNon200StatusCode(int status) throws IOException {
		mockHttpResponse(status, false, false);

		var inputStream = mock(InputStream.class);
		assertThrows(ServiceException.class, () -> cut.scanDocument(inputStream));
	}

	@Test
	void exceptionIsThrownIfRequestRespondWithNonJsonContentType() throws IOException {
		mockHttpResponse(200, false, false, "text/plain", true);

		var inputStream = mock(InputStream.class);
		assertThrows(ServiceException.class, () -> cut.scanDocument(inputStream));
	}

	@Test
	void noExceptionIfCorrectContentType() throws IOException {
		mockHttpResponse(200, false, false, "application/json", true);

		var inputStream = mock(InputStream.class);
		assertDoesNotThrow(() -> cut.scanDocument(inputStream));
	}

	@Test
	void noResponseEntityReturnsClean() throws IOException {
		mockHttpResponse(200, false, false, "application/json", false);

		var response = cut.scanDocument(mock(InputStream.class));

		assertThat(response).isEqualTo(MalwareScanResultStatus.CLEAN);
	}

	private HttpClient mockHttpResponse(int httpStatus, boolean malwareDetected,
			boolean encryptedContentDetected) throws IOException {
		return mockHttpResponse(httpStatus, malwareDetected, encryptedContentDetected, null, true);
	}

	private HttpClient mockHttpResponse(int httpStatus, boolean malwareDetected, boolean encryptedContentDetected,
			String contentTypeString, boolean responseEntityExists) throws IOException {
		when(clientProviderFactory.isServiceBound()).thenReturn(true);
		var httpClient = mock(HttpClient.class);
		var httpClientProvider = mock(HttpClientProvider.class);
		when(httpClientProvider.get()).thenReturn(httpClient);
		when(clientProviderFactory.getHttpClientProvider()).thenReturn(httpClientProvider);
		var response = mock(CloseableHttpResponse.class);
		when(httpClient.execute(any())).thenReturn(response);
		var statusLine = mock(StatusLine.class);
		when(response.getStatusLine()).thenReturn(statusLine);
		when(statusLine.getStatusCode()).thenReturn(httpStatus);
		if (responseEntityExists) {
			var entity = mock(HttpEntity.class);
			when(response.getEntity()).thenReturn(entity);
			when(entity.getContent()).thenReturn(new ByteArrayInputStream(
					getJsonResponse(malwareDetected, encryptedContentDetected).getBytes(StandardCharsets.UTF_8)));
			if (Objects.nonNull(contentTypeString)) {
				var contentType = mock(Header.class);
				when(contentType.getValue()).thenReturn(contentTypeString);
				when(contentType.getElements()).thenReturn(new HeaderElement[]{new BasicHeaderElement("charset", "utf-8")});
				when(entity.getContentType()).thenReturn(contentType);
			}
		}
		return httpClient;
	}

	private String getJsonResponse(boolean malwareDetected, boolean encryptedContentDetected) {
		return """
				{
						"malwareDetected": %s,
						"encryptedContentDetected": %s,
						"scanSize": 0,
						"mimeType": ""
				}""".formatted(malwareDetected, encryptedContentDetected);
	}

}
