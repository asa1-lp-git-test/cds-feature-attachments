package com.sap.cds.feature.attachments.service.malware;

import java.io.InputStream;
import java.time.Instant;
import java.util.Map;
import java.util.Objects;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.sap.cds.CdsData;
import com.sap.cds.Result;
import com.sap.cds.feature.attachments.generated.cds4j.com.sap.attachments.Attachments;
import com.sap.cds.feature.attachments.generated.cds4j.com.sap.attachments.StatusCode;
import com.sap.cds.feature.attachments.handler.draftservice.constants.DraftConstants;
import com.sap.cds.feature.attachments.service.AttachmentService;
import com.sap.cds.feature.attachments.service.malware.client.MalwareScanClient;
import com.sap.cds.feature.attachments.service.malware.client.model.MalwareScanResultStatus;
import com.sap.cds.ql.Select;
import com.sap.cds.ql.Update;
import com.sap.cds.reflect.CdsElementNotFoundException;
import com.sap.cds.reflect.CdsEntity;
import com.sap.cds.services.persistence.PersistenceService;

/**
	* The given input stream is scanned by using the malware scan service.
	* The result of the scan	is returned with status {@link MalwareScanResultStatus}.
	* In case of draft entity the data are tried to read from the draft entity first and if nothing is found
	* the data are read from the main entity.
	*/
public class DefaultAttachmentMalwareScanner implements AttachmentMalwareScanner {

	private static final Logger logger = LoggerFactory.getLogger(DefaultAttachmentMalwareScanner.class);
	private final PersistenceService persistenceService;
	private final AttachmentService attachmentService;
	private final MalwareScanClient malwareScanClient;

	public DefaultAttachmentMalwareScanner(PersistenceService persistenceService, AttachmentService attachmentService, MalwareScanClient malwareScanClient) {
		this.persistenceService = persistenceService;
		this.attachmentService = attachmentService;
		this.malwareScanClient = malwareScanClient;
	}

	@Override
	public void scanAttachment(CdsEntity attachmentEntity, Map<String, Object> keys) {
		logger.info("Service handler called to scan document for malware");

		var selectionResult = selectData(attachmentEntity, keys);

		if (selectionResult.result().rowCount() <= 0) {
			//nothing to do
			return;
		}

		var cdsData = selectionResult.result().single(CdsData.class);
		var status = scanDocument(cdsData);
		updateData(attachmentEntity, keys, status, cdsData);
	}

	private SelectionResult selectData(CdsEntity attachmentEntity, Map<String, Object> keys) {
		Result result;
		var siblingUsedForSelection = false;
		CdsEntity entity;
		try {
			entity = attachmentEntity.getTargetOf(DraftConstants.SIBLING_ENTITY);
			result = readData(keys, entity);
			siblingUsedForSelection = true;
		} catch (CdsElementNotFoundException exception) {
			entity = attachmentEntity;
			result = readData(keys, entity);
		}
		if (result.rowCount() <= 0 && siblingUsedForSelection) {
			entity = attachmentEntity;
			result = readData(keys, entity);
		}

		if (result.inlineCount() > 1) {
			throw new IllegalStateException("More than one attachment found for the given keys");
		}

		return new SelectionResult(entity, result);
	}

	private Result readData(Map<String, Object> keys, CdsEntity entity) {
		var select = Select.from(entity).columns(Attachments.DOCUMENT_ID, Attachments.CONTENT).matching(keys);
		return persistenceService.run(select);
	}

	private MalwareScanResultStatus scanDocument(CdsData data) {
		var documentId = (String) data.get(Attachments.DOCUMENT_ID);
		InputStream dbContent = (InputStream) data.get(Attachments.CONTENT);
		var content = Objects.nonNull(dbContent) ? dbContent : attachmentService.readAttachment(documentId);
		return malwareScanClient.scanDocument(content);
	}

	private synchronized void updateData(CdsEntity attachmentEntity, Map<String, Object> keys, MalwareScanResultStatus status, CdsData originData) {
		var selectionResult = selectData(attachmentEntity, keys);
		var selectionData = selectionResult.result();
		if (selectionData.rowCount() <= 0) {
			logger.warn("No attachment found for the given keys");
			return;
		} else if (!StringUtils.equals((String) selectionData.single(CdsData.class)
																																												.get(Attachments.DOCUMENT_ID), (String) originData.get(Attachments.DOCUMENT_ID))) {
			logger.warn("Attachment has been updated in the meantime. Skipping update for entity: {}", selectionResult.entity.getQualifiedName());
			return;
		}
		var updateData = CdsData.create();
		updateData.put(Attachments.STATUS_CODE, mapStatus(status));
		updateData.put(Attachments.SCANNED_AT, Instant.now());
		logger.debug("CdsData shall be updated for entity: {}", selectionResult.entity.getQualifiedName());
		var update = Update.entity(selectionResult.entity).data(updateData).matching(keys);
		var result = persistenceService.run(update);
	}

	private String mapStatus(MalwareScanResultStatus status) {
		return switch (status) {
			case CLEAN -> StatusCode.CLEAN;
			case INFECTED, ENCRYPTED -> StatusCode.INFECTED;
			default -> StatusCode.NO_SCANNER;
		};
	}

	private record SelectionResult(CdsEntity entity, Result result) {
	}

}
